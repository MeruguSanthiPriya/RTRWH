<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive Map - Rainwater Harvesting</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            margin: 0;
            padding: 0;
            background-color: #f0f2f5;
        }
        #map {
            height: 100vh;
            width: 100vw;
        }
        .leaflet-popup-content-wrapper {
            border-radius: 8px;
        }
        .leaflet-popup-content {
            margin: 15px;
            font-size: 14px;
            line-height: 1.6;
        }
        .leaflet-popup-content h3 {
            margin: 0 0 10px;
            font-size: 16px;
            color: #333;
            border-bottom: 1px solid #eee;
            padding-bottom: 5px;
        }
        .leaflet-popup-content p {
            margin: 5px 0;
        }
        .leaflet-popup-content strong {
            color: #555;
        }
        .map-controls {
            position: absolute;
            top: 10px;
            right: 10px;
            z-index: 1000;
            background: white;
            padding: 10px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.2);
        }
        .map-controls h3 {
            margin: 0 0 10px;
            font-size: 16px;
        }
        .control-buttons {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }
        .control-buttons label {
            display: block;
            padding: 8px 12px;
            background: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        .control-buttons input[type="radio"] {
            display: none;
        }
        .control-buttons input[type="radio"]:checked + label {
            background: #007bff;
            color: white;
            border-color: #007bff;
        }
        .legend {
            position: absolute;
            bottom: 20px;
            left: 12px;
            transform: none;
            z-index: 1000;
            background: rgba(255, 255, 255, 0.9);
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.2);
            max-width: 200px;
            cursor: move; /* Add move cursor to indicate draggable */
        }
        .legend h4 {
            margin: 0 0 10px;
            font-size: 14px;
        }
        .legend-item {
            display: flex;
            align-items: center;
            margin-bottom: 5px;
        }
        .legend-color {
            width: 18px;
            height: 18px;
            margin-right: 8px;
            border: 1px solid #ccc;
            border-radius: 50%; /* Make legend colors circles */
        }

        /* Gradient legend for rainfall */
        .legend-gradient {
            width: 260px;
            height: 14px;
            background: linear-gradient(90deg, #ffffcc, #a1dab4, #41b6c4, #2c7fb8, #253494);
            border-radius: 6px;
            border: 1px solid rgba(0,0,0,0.15);
            margin-top: 8px;
        }
        .legend-scale {
            display: flex;
            justify-content: space-between;
            font-size: 11px;
            color: #fff;
            margin-top: 6px;
        }

        /* 3D Bubble Effect for Map Markers */
        .map-marker-bubble {
            transition: all 0.2s ease-in-out;
            filter: drop-shadow(3px 5px 4px rgba(0,0,0,0.4));
        }
        .map-marker-bubble:hover {
            filter: drop-shadow(5px 8px 6px rgba(0,0,0,0.5));
        }

        /* Seasonal Effects */
        .monsoon-overlay {
            background: linear-gradient(45deg, rgba(34, 211, 238, 0.1), rgba(6, 182, 212, 0.1));
            animation: shimmer 3s ease-in-out infinite;
        }

        .summer-overlay {
            background: linear-gradient(45deg, rgba(251, 191, 36, 0.1), rgba(245, 158, 11, 0.1));
        }

        /* 3D Terrain Container */
        #terrain-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 500;
            opacity: 0.7;
        }

        /* Enhanced Controls */
        .map-controls {
            background: rgba(15, 23, 42, 0.9);
            backdrop-filter: blur(20px);
            border: 1px solid rgba(34, 211, 238, 0.3);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            color: white;
        }

        .control-buttons label {
            background: linear-gradient(135deg, rgba(34, 211, 238, 0.1), rgba(6, 182, 212, 0.1));
            border: 1px solid rgba(34, 211, 238, 0.2);
            transition: all 0.3s ease;
        }

        .control-buttons input[type="radio"]:checked + label {
            background: linear-gradient(135deg, #22d3ee, #06b6d4);
            box-shadow: 0 4px 15px rgba(34, 211, 238, 0.4);
            transform: translateY(-1px);
        }

        /* Enhanced Legend */
        .legend {
            background: rgba(15, 23, 42, 0.9);
            backdrop-filter: blur(20px);
            border: 1px solid rgba(34, 211, 238, 0.3);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            color: white;
        }
        .legend h4 { color: #22d3ee; }

        /* Pulsing circle for user bubble */
        .pulse {
            animation: pulse 2s infinite;
        }
        @keyframes pulse {
            0% { box-shadow: 0 0 0 0 rgba(34, 211, 238, 0.6); }
            70% { box-shadow: 0 0 0 16px rgba(34, 211, 238, 0); }
            100% { box-shadow: 0 0 0 0 rgba(34, 211, 238, 0); }
        }
    </style>
</head>
<body>

    <div id="map"></div>

    <div class="absolute top-4 right-4 z-50">
        <select id="languageSelect" class="glass-input rounded-md px-3 py-2 text-white focus:outline-none">
            <option value="en">English</option>
            <option value="hi">हिंदी</option>
            <option value="ta">தமிழ்</option>
            <option value="te">తెలుగు</option>
            <option value="bn">বাংলা</option>
            <option value="gu">ગુજરાતી</option>
            <option value="kn">ಕನ್ನಡ</option>
            <option value="ml">മലയാളം</option>
        </select>
    </div>

    <div class="map-controls">
        <h3>Visualize by Layer</h3>
        <div class="control-buttons" id="layer-controls">
            <input type="radio" id="aquifer" name="layer" value="aquifer">
            <label for="aquifer">Aquifer Type</label>

            <input type="radio" id="rainfall" name="layer" value="rainfall" checked>
            <label for="rainfall">Rainfall</label>

            <input type="radio" id="soil" name="layer" value="soil">
            <label for="soil">Soil Type</label>

            <input type="radio" id="infiltration" name="layer" value="infiltration">
            <label for="infiltration">Infiltration Rate</label>
        </div>
    </div>

    <div class="legend" id="legend"></div>
    <script id="user-data" type="application/json">{{ user_location | tojson }}</script>
    <script id="nearest-data" type="application/json">{{ nearest_location | tojson }}</script>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const userLocationData = JSON.parse(document.getElementById('user-data').textContent || 'null');
            const nearestLocation = JSON.parse(document.getElementById('nearest-data').textContent || 'null');

            // Default center if no user location
            let defaultLat = 20.5937; // Center of India
            let defaultLon = 78.9629;
            let defaultZoom = 5;

            // Use user location if available, otherwise nearest, otherwise default
            let centerLat = defaultLat;
            let centerLon = defaultLon;
            let zoomLevel = defaultZoom;
            if (userLocationData && userLocationData.Latitude && userLocationData.Longitude) {
                centerLat = userLocationData.Latitude;
                centerLon = userLocationData.Longitude;
                zoomLevel = 12;
            } else if (nearestLocation && nearestLocation.Latitude && nearestLocation.Longitude) {
                centerLat = nearestLocation.Latitude;
                centerLon = nearestLocation.Longitude;
                zoomLevel = 10;
            }

            // 1. Initialize the map
            let map = L.map('map').setView([centerLat, centerLon], zoomLevel);
            
            L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
            }).addTo(map);

            let geoJsonLayer;
            let overlayLayer;

            // 2. Define color schemes and categories
            const layers = {
                rainfall: {
                    name: 'Rainfall Level',
                    property: 'Rainfall_mm',
                    categories: [
                        { range: [0, 500], color: '#ffffcc', label: 'Very Low (<500mm)' },
                        { range: [500, 750], color: '#a1dab4', label: 'Low (500-750mm)' },
                        { range: [750, 1000], color: '#41b6c4', label: 'Moderate (750-1000mm)' },
                        { range: [1000, 2000], color: '#2c7fb8', label: 'High (1000-2000mm)' },
                        { range: [2000, Infinity], color: '#253494', label: 'Very High (>2000mm)' }
                    ],
                    getColor: (value) => {
                        const category = layers.rainfall.categories.find(c => value >= c.range[0] && value < c.range[1]);
                        return category ? category.color : '#808080';
                    }
                },
                aquifer: {
                    name: 'Aquifer Type',
                    property: 'Aquifer_Type',
                    categories: [
                        { value: 'Confined', color: '#f59e0b', label: 'Confined' },
                        { value: 'Unconfined', color: '#06b6d4', label: 'Unconfined' },
                        { value: 'Semi-confined', color: '#10b981', label: 'Semi-confined' },
                        { value: 'Fractured', color: '#8b5cf6', label: 'Fractured' },
                        { value: 'Other', color: '#9ca3af', label: 'Other' }
                    ],
                    getColor: (value) => {
                        if (!value) return '#9ca3af';
                        const v = String(value).toLowerCase();
                        const match = layers.aquifer.categories.find(c => c.value.toLowerCase() === v);
                        return match ? match.color : '#9ca3af';
                    }
                },
                soil: {
                    name: 'Soil Type',
                    property: 'Soil_Type',
                    categories: [
                        { value: 'Sandy', color: '#fed976', label: 'Sandy' },
                        { value: 'Loamy', color: '#ae017e', label: 'Loamy' },
                        { value: 'Clayey', color: '#cc4c02', label: 'Clayey' },
                        { value: 'Other', color: '#bdbdbd', label: 'Other' }
                    ],
                    getColor: (value) => {
                        const category = layers.soil.categories.find(c => c.value.toLowerCase() === value.toLowerCase());
                        return category ? category.color : layers.soil.categories.find(c => c.value === 'Other').color;
                    }
                },
                infiltration: {
                    name: 'Infiltration Rate',
                    property: 'Infiltration_Rate_mm_per_hr',
                    categories: [
                        { range: [0, 10], color: '#fa9fb5', label: 'Low (<10 mm/hr)' },
                        { range: [10, 15], color: '#7bccc4', label: 'Moderate (10-15 mm/hr)' },
                        { range: [15, Infinity], color: '#2b8cbe', label: 'High (>15 mm/hr)' }
                    ],
                    getColor: (value) => {
                        const category = layers.infiltration.categories.find(c => value >= c.range[0] && value < c.range[1]);
                        return category ? category.color : '#808080';
                    }
                }
            };

            // 4. Create GeoJSON features for both locations
            let features = [];
            if (userLocationData) {
                userLocationData.isUser = true;
                features.push({
                    type: 'Feature',
                    properties: userLocationData,
                    geometry: {
                        type: 'Point',
                        coordinates: [userLocationData.Longitude, userLocationData.Latitude]
                    }
                });
            }
            if (nearestLocation) {
                features.push({
                    type: 'Feature',
                    properties: nearestLocation,
                    geometry: {
                        type: 'Point',
                        coordinates: [nearestLocation.Longitude, nearestLocation.Latitude]
                    }
                });
            }

            if (features.length > 0) {
                geoJsonLayer = L.geoJSON(features, {
                    pointToLayer: (feature, latlng) => {
                        const isUserBubble = feature.properties.isUser;
                        return L.circleMarker(latlng, {
                            radius: isUserBubble ? 20 : 10, /* Increased user bubble size */
                            weight: isUserBubble ? 4 : 1, /* Increased user bubble border */
                            opacity: 1,
                            fillOpacity: 0.85,
                            color: isUserBubble ? '#22d3ee' : '#333',
                            className: isUserBubble ? 'map-marker-bubble pulse' : 'map-marker-bubble'
                        });
                    },
                    onEachFeature: (feature, layer) => {
                        const props = feature.properties;
                        const title = props.isUser ? `<h3>${props.Region_Name} (Estimated Data)</h3>` : `<h3>${props.Region_Name}</h3>`;
                        const popupContent = `
                            ${title}
                            <p><strong>State:</strong> ${props.State}</p>
                            <p><strong>Rainfall:</strong> ${props.Rainfall_mm} mm</p>
                            <p><strong>Soil Type:</strong> ${props.Soil_Type}</p>
                            <p><strong>Aquifer Type:</strong> ${props.Aquifer_Type}</p>
                            <p><strong>Infiltration Rate:</strong> ${props.Infiltration_Rate_mm_per_hr} mm/hr</p>
                        `;
                        layer.bindPopup(popupContent);

                        // Enhanced interactions
                        layer.on('mouseover', function(e) {
                            e.target.setStyle({
                                fillOpacity: 0.95,
                                weight: 4,
                                color: '#FFD700'
                            });
                        });
                        
                        layer.on('mouseout', function(e) {
                            const isUserBubble = e.target.feature.properties.isUser;
                            e.target.setStyle({
                                fillOpacity: 0.85,
                                weight: isUserBubble ? 4 : 1, /* Match increased border weight */
                                color: isUserBubble ? '#22d3ee' : '#333'
                            });
                        });
                    }
                }).addTo(map);

                // Open user's popup by default
                geoJsonLayer.eachLayer(layer => {
                    if (layer.feature.properties.isUser) {
                        layer.openPopup();
                    }
                });

                updateLegend('rainfall');
            } else {
                // If no features (no entry provided), try browser geolocation
                if (navigator.geolocation) {
                    navigator.geolocation.getCurrentPosition((pos) => {
                        const lat = pos.coords.latitude;
                        const lon = pos.coords.longitude;
                        map.setView([lat, lon], 13);

                        const userFeature = {
                            type: 'Feature',
                            properties: { isUser: true, Region_Name: 'Your Location', State: '-', Rainfall_mm: 0, Soil_Type: '-', Aquifer_Type: '-', Infiltration_Rate_mm_per_hr: 0 },
                            geometry: { type: 'Point', coordinates: [lon, lat] }
                        };
                        geoJsonLayer = L.geoJSON([userFeature], {
                            pointToLayer: (feature, latlng) => L.circleMarker(latlng, {
                                radius: 14,
                                weight: 3,
                                opacity: 1,
                                fillOpacity: 0.85,
                                color: '#22d3ee',
                                className: 'map-marker-bubble pulse'
                            })
                        }).addTo(map);
                        updateLegend('rainfall');
                        loadOverlay('rainfall');
                    });
                }
            }

            // 5. Update map layer function (for user bubble coloring by data variable)
            function updateMapLayer(layerKey) {
                const layerConfig = layers[layerKey];

                geoJsonLayer.eachLayer(layer => {
                    const value = layer.feature.properties[layerConfig.property];
                    layer.setStyle({
                        fillColor: layerConfig.getColor(value),
                        color: layer.feature.properties.isUser ? '#FFD700' : '#333'
                    });
                });

                updateLegend(layerKey);
            }

            // 6. Load overlay layers from backend (GeoJSON) and update user bubble color to match
            async function loadOverlay(layerKey) {
                if (overlayLayer) {
                    map.removeLayer(overlayLayer);
                    overlayLayer = null;
                }

                const lat = centerLat;
                const lon = centerLon;
                const radius = 250; // km

                let url = '';
                // No overlay fetches for attribute-only layers (aquifer/rainfall/soil/infiltration)

                if (!url) return;
                let data = null;
                try {
                    const res = await fetch(url);
                    if (!res.ok) {
                        console.error('Layer fetch failed', layerKey, res.status);
                        return;
                    }
                    data = await res.json();
                } catch (e) {
                    console.error('Layer fetch error', layerKey, e);
                    return;
                }

                // Major Aquifers removed

                // Aquifer Type is attribute-only; handled by updateMapLayer/legend
                if (layerKey === 'aquifer') {
                    updateMapLayer('aquifer');
                    // Match user color to aquifer type color
                    let aquiferValue = null;
                    if (geoJsonLayer) {
                        geoJsonLayer.eachLayer(l => {
                            if (l.feature.properties.isUser) {
                                aquiferValue = l.feature.properties.Aquifer_Type;
                            }
                        });
                    }
                    const color = layers.aquifer.getColor(aquiferValue);
                    setUserMarkerColor(color);
                    updateLegend('aquifer');
                }

                if (layerKey === 'rainfall') {
                    // color the user and nearest markers by rainfall; no polygon overlay
                    updateMapLayer('rainfall');
                    setUserMarkerColor('#253494');
                    updateLegend('rainfall');
                }
            }

            function setUserMarkerColor(color) {
                if (!geoJsonLayer) return;
                geoJsonLayer.eachLayer(layer => {
                    if (layer.feature.properties.isUser) {
                        layer.setStyle({ color, fillColor: color });
                    }
                });
            }

            // 7. Update legend function
            function updateLegend(layerKey) {
                const legendContainer = document.getElementById('legend');
                const layerConfig = layers[layerKey];

                if (layerKey === 'aquifer') {
                    const layerConfig = layers.aquifer;
                    legendContainer.innerHTML = `
                        <h4>${layerConfig.name}</h4>
                        <div class="legend-item"><div class="legend-color" style="background:#f59e0b"></div><span>Confined</span></div>
                        <div class="legend-item"><div class="legend-color" style="background:#06b6d4"></div><span>Unconfined</span></div>
                        <div class="legend-item"><div class="legend-color" style="background:#10b981"></div><span>Semi-confined</span></div>
                        <div class="legend-item"><div class="legend-color" style="background:#8b5cf6"></div><span>Fractured</span></div>
                        <div class="legend-item"><div class="legend-color" style="background:#9ca3af"></div><span>Other</span></div>`;
                    return;
                }

                if (layerKey === 'rainfall') {
                    let html = `<h4>${layerConfig.name}</h4>`;
                    layerConfig.categories.forEach(c => {
                        html += `
                            <div class="legend-item">
                                <div class="legend-color" style="background-color: ${c.color};"></div>
                                <span>${c.label}</span>
                            </div>`;
                    });
                    legendContainer.innerHTML = html;
                    return;
                }

                if (layerKey === 'soil') {
                    legendContainer.innerHTML = `
                        <h4>${layerConfig.name}</h4>
                        <div class="legend-item"><div class="legend-color" style="background:#fed976"></div><span>Sandy</span></div>
                        <div class="legend-item"><div class="legend-color" style="background:#ae017e"></div><span>Loamy</span></div>
                        <div class="legend-item"><div class="legend-color" style="background:#cc4c02"></div><span>Clayey</span></div>
                        <div class="legend-item"><div class="legend-color" style="background:#bdbdbd"></div><span>Other</span></div>`;
                    return;
                }

                if (layerKey === 'infiltration') {
                    legendContainer.innerHTML = `
                        <h4>${layerConfig.name}</h4>
                        <div class="legend-item"><div class="legend-color" style="background:#fa9fb5"></div><span>Low (<10 mm/hr)</span></div>
                        <div class="legend-item"><div class="legend-color" style="background:#7bccc4"></div><span>Moderate (10–15)</span></div>
                        <div class="legend-item"><div class="legend-color" style="background:#2b8cbe"></div><span>High (>15)</span></div>`;
                    return;
                }

                let legendHTML = `<h4>${layerConfig.name}</h4>`;
                layerConfig.categories.forEach(category => {
                    legendHTML += `
                        <div class="legend-item">
                            <div class="legend-color" style="background-color: ${category.color};"></div>
                            <span>${category.label || category.value}</span>
                        </div>`;
                });
                legendContainer.innerHTML = legendHTML;
            }

            function renderLegendDiscrete(title, items) {
                const legendContainer = document.getElementById('legend');
                let legendHTML = `<h4>${title}</h4>`;
                items.forEach(item => {
                    legendHTML += `
                        <div class="legend-item">
                            <div class="legend-color" style="background-color: ${item.color};"></div>
                            <span>${item.label}</span>
                        </div>`;
                });
                legendContainer.innerHTML = legendHTML;
            }

            // 8. Event listeners for controls
            const controls = document.getElementById('layer-controls');
            controls.addEventListener('change', (event) => {
                if (event.target.name === 'layer') {
                    const key = event.target.value;
                    loadOverlay(key);
                    // Ensure attribute-only layers recolor immediately
                    if (['rainfall','soil','infiltration','aquifer'].includes(key)) {
                        updateMapLayer(key);
                    }
                }
            });

            // 7. Draggable Legend Logic
            const legend = document.getElementById('legend');
            let isDragging = false;
            let offsetX, offsetY;

            // On mouse down, record the starting position and set dragging flag
            legend.addEventListener('mousedown', (e) => {
                isDragging = true;
                
                // Calculate the offset from the top-left corner of the element
                const rect = legend.getBoundingClientRect();
                offsetX = e.clientX - rect.left;
                offsetY = e.clientY - rect.top;

                // We need to switch to using top/left for positioning
                if (!legend.style.left) {
                    legend.style.left = `${rect.left}px`;
                    legend.style.top = `${rect.top}px`;
                    legend.style.bottom = 'auto'; // Override the initial 'bottom' style
                }
                
                legend.style.cursor = 'grabbing';
            });

            // On mouse move, if dragging, update the element's position
            document.addEventListener('mousemove', (e) => {
                if (!isDragging) return;
                e.preventDefault(); // Prevent text selection while dragging

                // New position is mouse position minus the initial offset
                const newX = e.clientX - offsetX;
                const newY = e.clientY - offsetY;

                legend.style.left = `${newX}px`;
                legend.style.top = `${newY}px`;
            });

            // On mouse up, stop dragging
            document.addEventListener('mouseup', () => {
                if (isDragging) {
                    isDragging = false;
                    legend.style.cursor = 'move';
                }
            });

            // Load default overlay layer
            loadOverlay('groundwater');
        });
    </script>
    <script src="{{ url_for('static', filename='js/language-switcher.js') }}"></script>

</body>
</html>
